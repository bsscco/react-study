### 문제
- Asynchronity와 Mutation의 조합으로 복잡함이 증가함에 따라 상태 변화의 결과를 예측할 수 없게 됨.
- Asynchronity와 Mutation을 제한함으로써 복잡함을 없애자.

### 문제 해결을 위한 원칙
- 하나의 상태 트리만 존재하도록 한다.
- 상태 변화를 시키고자 할 땐 이전 상태와 새 상태를 바꿔치기 한다. -> Immutation 보장
- 상태 변화를 시키고자 할 땐 비동기, Random, 커서 같은 불확실 한 요소를 배제한다. -> Synchronity 보장

### 기타 효과
- 시간을 거슬러 올라가는 등의 디버깅도 쉽게 가능하다.
- 테스트도 순수 객체로 구성된 액션을 던지면 되기 때문에 쉽다.

### 타 라이브러리 연계
- Immutation에 Immutable.js를 연계하면 도움이 된다.
- 비동기 처리에 Rx.js를 연계하면 도움이 된다.

### 액션이란?
- 상태 변경을 원할 때 스토어로 보내는 데이터 객체.
- 어떤 상태를 어떻게 변경할지를 나타낸다.

### 액션 생성자란?
- 액션을 생성하는 함수
- 보통 액션의 수가 많아지면 기능(모듈) 단위로 액션 생성자를 만들어서 분류하기 때문에 액션 생성자는 여러 개가 될 수 있다.

### 스토어란?
- 앱 당 오직 하나의 스토어
- 상태 트리를 가진다.
- 받은 액션을 등록된 리듀서들에게 전달하고 반환받은 상태를 ```setState()``` 한다. 이후 등록된 리스너들에게 상태가 변경됐음을 알린다.

### 리듀서란?
- 비동기, Random 같은 비수순 코드가 없어야 하는 순수함수(같은 인자에 항상 같은 결과를 반환해야 한다.)
- 이전 상태를 변경하려면 반드시 새 상태를 반환해야 한다.
- 리듀서 또한 액션 수가 많아지면 기능(모듈) 단위로 만들어서 분류하기 때문에 여러 개가 될 수 있다.

### 데이터의 흐름(일방향)
- 앱 내 어디서든 ```store.dispatch(action)```를 호출
- 스토어가 리듀서들에게 액션을 전달
- 받은 액션을 처리할 수 있는 리듀서는 새로운 상태를 반환
- 스토어는 반환받은 상태를 상태 트리에 반영
- 바로 UI가 갱신됨.

### React와 함께 사용하기
- ```npm install --save redux react-redux```
- Redux와의 연결은 Smart 컴포넌트에서만 하는 것이 복잡성을 줄일 수 있다.
- Dumb 컴포넌트들은 상태를 받아서 처리하며, 어떻게 바꾸는지는 알지 못한다.

### 비동기 액션
- 비동기를 위한 액션 종류
	- 요청 시작을 알리는 액션
	- 응답 성공을 알리는 액션
	- 응답 실패를 알리는 액션
- ```redux-actions```와 연계하면 액션을 만들기 편하다.
- 어렵다... 이해 잘 안됨.

### 비동기 흐름
- Redux는 동기 흐름만 지원한다.
- ```react-thunk```, ```react-promise``` 같은 미들웨어를 통해 비동기 흐름을 만들 수 있다.
- 비동기 미들웨어는 스토어의 dispatch()를 감싸서 액션이 아니라 함수나 promise 같은 다른 것들을 보낼 수 게 해준다.

### 미들웨어란?
- 미들웨어를 사용하면 체이닝을 통해 조합하는 게 
가능하다.

