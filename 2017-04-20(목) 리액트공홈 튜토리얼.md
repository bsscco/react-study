# Javascript

### 간단 소개
- Java-like 문법

### 개념
- Number
- String
	- string.length
- Math.random()
- typeof
- == 그리고 ===
- prompt()
- false
	- ''
	- undefined
	- null
	- NaN
	- 0
	- []
	- {}
- document.write()
- function
	- function foo() {}
	- var foo = function() {}
	- 객체로서의 함수
	- 비동기 처리 시 콜백으로서의 함수
- [] Array
	- array.length
	- array.push()
	- array.concat()
	- array.unshift()
	- array.shift()
	- array.splice()
	- array.pop()
	- array.sort()
	- array.reverse()
	- for(idx in array)
- {} Object(=Dictionary)
	- obj['property']
	- obj.property
	- for(key in obj)
- 모듈화
	- 관심사의 분리
	- 코드 재활용
	- 브라우저 캐시
- 호스트 환경이란
- 라이브러리
- 튜토리얼
	- 문법에 대한 설명
- 레퍼런스
	- 문법 사전
- 정규표현식
	- 컴파일 : 검출을 원하는 패턴을 만드는 일
	- pattern = /\d*/
	- pattern = new RegExp('\d*')
	- pattern.exec('123-456')
	- pattern.test('123-456')
	- '123-456'.match(/\d*/)
	- '123-456'.replace(/\d*/, '999') : only first match element
- var
	- 전역변수가 있음 -> 함수 안에서 var와 함께 선언 -> 지역변수
	- 전역변수가 있음 -> 함수 안에서 var 없이 선언 -> 전역변수
	- 전역변수가 없음 -> 함수 안에서 var와 함께 선언 -> 지역변수
	- 전역변수가 없음 -> 함수 안에서 var 없이 선언 -> 전역변수
	- 변수를 선언할 땐 되도록 var를 붙여야 전역변수와의 충돌을 예방할 수 있다.
- 클로저
	- 내부함수에서 외부함수의 지역변수를 사용할 수 있다.
- function
	- arguments
		- 함수에 실제로 들어온 모든 인자의 정보
		- function.length : 함수에서 정의된 인자수
	- fuction.apply(context, arg1, arg2, ...)
		- context의 속성으로 function을 지정해서 호출한 뒤에 속성에서 fuction을 제거한다.
	- function.call(arg1, arg2, ...)
		- function()과 같다.
- 객체
	- property
	- method
	- 생성자 함수
		> function Person(name) {
		>	this.name = name;
		>	this.instroduce = function() {
		>		return 'My name is ' + this.name;		
		>	}
		> }
		> var person = new Person('수키')
		
- window
	- 전역객체
	- 전역객체의 이름과 프로퍼티, 메소드들은 호스트환경에 따라서 다르다.

- this
	- 이 함수를 감싸는 객체를 가리킨다.
	- apply(context)를 통해 들어왔다면 context를 가리킨다.
- prototype
	- 생성자 함수 간 상속을 위해 사용한다.
	- Sub.prototype = new Super()
- 내장 객체(=내장 생성자 함수)
	- Object
		- Object객체를 확장(prototype.contain = ....)하면 모든 객체를 확장할 수 있다.
	- Function
	- Array
	- String
	- Boolean
	- Number
	- Math
	- Date
	- RegExp
- primitive type
	- 원시 타입은 확장할 수도, 속성을 추가할 수도 없다.
	- number
	- string
	- boolean
	- null
	- undefined
- wrapper 객체
	- String
	- Number
	- Boolean
	
### 재진입하기
https://developer.mozilla.org/ko/docs/A_re-introduction_to_JavaScript


# TicTacToe 주요 설명

### props
- 바뀌지 않는 상수 속성
- 부모 컴포넌트에서 -> 자식 컴포넌트로 전달한다.
- props로 컴포넌트가 셋팅되도록 만들면 컴포넌트의 재활용도가 높아진다.

### state
- 바뀌는 상태 속성
- 컴포넌트 안에 캡슐화 되어있어서 부모 컴포넌트가 접근할 수 없다.
- state 변경 시 immutable이 좋은 이유
  1. 상태를 복사해서 변경하기 때문에 추적이 가능한 구조를 만들 수 있다.
  2. 상태 복사본과 원본의 변경점만 비교하기 때문에 어떤 부분만 렌더링 할지 효율적으로 결정할 수 있다.
  
### key
- React에 의해 다루어지는 특별한 프로퍼티
- props는 아님. this.props.key로 접근할 수 없다.
- 리스트 요소의 UI 갱신이 필요할 때 React는 key를 사용해 자식 컴포넌트들을 구별한다.
- key가 제거되면 컴포넌트도 제거되고, key가 생성되면 컴포넌트도 생성됩니다. key의 값을 바꾸면 컴포넌트는 새로운 상태로 재생성 된다.
- 만약 리스트에서 자식 컴포넌트들에게 key를 설정하지 않으면 React가 array index를 key로써 설정할 겁니다. 
	- array index를 사용하게 하는 것은 좋은 선택이 아닙니다. 리스트 내 아이템을 추가/제거/재정렬을 여러 번 하다보면 헷갈리기 때문입니다.(맞나?)
	- key는 글로벌하게 unique 할 필요는 없고, 형제 컴포넌트 간에만 unique 하면 됩니다.


# 튜토리얼을 마치고 느낀 점
- UI 상태 갱신이 자동화 되어있어서 사고가 단순해지고 UI 제작이 매우 쉽다.
